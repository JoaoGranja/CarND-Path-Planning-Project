# **Path Planning** 

---

**Path Planning Project**

In this project, I will design a path planner in C++ language that is able to create smooth, safe paths for the car to follow along a 3 lane highway with traffic. A successful path planner will be able to keep inside its lane, avoid hitting other cars, and pass slower moving traffic all by using localization, sensor fusion, and map data.

The project rubrics are the following:
* The code compiles correctly;
* The car is able to drive at least 4.32 miles without incident;
* The car drives according to the speed limit;
* Max Acceleration and Jerk are not Exceeded;
* Car does not have collisions;
* The car stays in its lane, except for the time between changing lanes;
* The car is able to change lanes;
* There is a reflection on how to generate paths.

[//]: # (Image References)

[video]: ./video/video.mov "Final video"

## Writeup Report

In this report I will address all project rubrics, explaining my approach and presenting some results obtained.

---
### Overview of my project approach

This project is composed mainly by 4 files:
* helpers.h - header file with useful functions;
* json.hpp  - header file for using json on c++
* spline.h  - header file for using spline on c++
* main.cpp  - cpp file which interacts with the simulator sending the trajectory points to the car

I use three variables to keep track of the car states:
* curr_vel   - current velocity of the car
* curr_lane  - current lane of the car
* curr_state - current state of the car

My solution can be divided in two steps. First task is to determine the next state for the car to follow. This task is performed by the function "choose_next_state" which is defined on "helpers.h" file. Basically this fuction tests if a lane change is feasible, calculate the cost of each lane (through the function "vel_cost" and some penalty in case the next lane is not in the middle and it is not in KL (Keep Lane). These two penalties are added to benefit the center lane and keeping on the same lane in case cost difference is not relevant.

After the next state is chosen, the next lane and reference velocity is calculated through the functions "successor_lane" and "successor_velocity" functions.
Taking into account these two variables, a trajectory is generated on the function "trajectory_generation". This trajectory is composed by the last path points plus a new part generated by the spline function. This new part takes into account the next lane and the reference velocity to follow. The formula used to determine the next points is "delta_x = v*t+0.5*a*t*t" with acceleration (a) = 0.224 and time (t) = 0.02. The velocity is also updated with delta_v = a*t;

### Project Rubics discussion

#### The code compiles correctly

On build directory, the project compiles correctly using the command "cmake .. && make"


#### The car is able to drive at least 4.32 miles without incident

In this video ![alt text][video] it is possible to verify that the car is able to drive at least 4.32 miles without incident.


#### The car drives according to the speed limit

The global variable MAX_SPEED is defined as 49.5 which is the maximum value for the reference velocity for the car to follow.


#### Max Acceleration and Jerk are not Exceeded

Generating the trajectory points, the maximum acceleration used is 0.224 miles/h to guarantee that the acceleration of the car is not exceeded.
Moreover, using the spline library, the trajectory points are generated over a smooth path so Jerk is also not exceeded.

#### Car does not have collisions

In this video ![alt text][video] it is possible to verify that the car does not have collisions.


#### The car stays in its lane, except for the time between changing lanes

The generated trajectory is calculated based on the center of the lane to follow. So the car stays in its lane, except for the time between changing lanes.

#### The car is able to change lanes

In this video ![alt text][video] it is possible to verify that the car is able to change lanes to move faster.

#### There is a reflection on how to generate paths

This reflection is the purpose of this document.
